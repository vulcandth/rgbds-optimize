# Runtime-loaded optimization definitions.
# This file is intentionally user-editable; regexes are compiled once at startup.

regexes:
  REDUNDANT_ARGUMENTS: '^(?:add|adc|sub|sbc|and|xor|or|cp) a,'
  NO_OP_LD_PY: '^ld ([abcdehl]), \1$'
  NO_OP_ADD_SUB: '^(?:add|sub) (?:a, )?(?:[%$&]?0+|FALSE)$'
  INEFFICIENT_HRAM_LOAD: '^ld a, \[[hr][^l]'
  INEFFICIENT_HRAM_STORE: '^ld \[[hr][^l]'
  A_EQ_0: '^ld a, (?:[%$&]?0+|FALSE)$'
  A_INC_DEC: '^(?:add|sub) (?:a, )?[%$&]?0*1$'
  A_NOT: '^xor (?:255|-[%$&]?0*1|\$[Ff][Ff]|%11111111|&377)$'
  LD_R_A: '^ld [bcdehl], a'
  LD_A_IMM: '^ld a, [^afbcdehl\[]'
  SUB_R: '^sub [bcdehl]'
  JUMP_NC: '^(jr|jp|jmp) nc,'
  JUMP_C: '^(jr|jp|jmp) c,'
  JUMP_NC_OR_C: '^(jr|jp|jmp) n?c,'
  JUMP_NZ_OR_ZC: '^(jr|jp|jmp) n?[zc],'
  JR_JP_JMP_ANY: '^(jr|jp|jmp) '
  SRL_A: '^srl a$'
  LD_DST_A: '^ld ([bcdehl]|\[hl\]), a'
  ADC_SBC_0: '^(adc|sbc) [%$&]?0+$'
  LD_A_0: '^ld a, [%$&]?0+$'
  AND_IMM: '^and (?:a, )?[^afbcdehl\[]'
  CP_IMM: '^cp (?:a, )?[^afbcdehl\[]'
  LD_RH_A: '^ld [bcdehl], a$'
  LD_A_RH: '^ld a, [bcdehl]$'
  OR_R: '^or (?:a, )?[bcdehl]$'
  LDH_R: '^ldh? [abcdehl],'

  ADD_A_LCE_OR_IMM: '^add (?:a, )?(?:[lce]|[^afbdh\[])'
  LD_LCE_A: '^ld [lce], a'
  LD_A_HBD_OR_0: '^ld a, (?:[hbd]|[%$&]?0+$)'
  LD_A_BCDEHL_OR_0: '^ld a, (?:[bcdehl]|[%$&]?0+$)'
  ADC_BCDEHL_OR_0: '^adc (?:[bcdehl]|[%$&]?0+$)'
  SBC_BCDEHL_OR_0: '^sbc (?:[bcdehl]|[%$&]?0+$)'
  ADC_HBD_OR_0: '^adc (?:[hbd]|[%$&]?0+$)'
  LD_HBD_A: '^ld [hbd], a'
  LD_HBD_0: '^ld [hbd], [%$&]?0+$'

  LD_PAIR_IMM: '^ld (?:hl|bc|de), [^\[]'
  ADD_LCE: '^add (?:a, )?(?:[lce])$'
  ADC_HBD: '^adc (?:a, )?(?:[hbd])$'
  SUB_LCE: '^sub (?:a, )?(?:[lce])$'
  LD_A_MEM_NOT_HBD: '^ld a, \[[^hbd]'
  LD_LH_A: '^ld [lh], a$'

  LD_MEMHL_IMM: '^ld \[hl\], [^afbcdehl\[]'
  LD_MEMHL_R: '^ld \[hl\], [bcdehl]$'
  LD_R_MEMHL: '^ld [bcde], \[hl\]$'

  LD_R_IMM: '^ld [bcdehl], [^afbcdehl\[]'
  LD_HL_IMM: '^ld hl, [^\[]'
  LD_BC_IMM: '^ld bc, [^\[]'
  LD_HL_IMM_OR_POP_HL: '^(?:ld hl,|pop hl)'

  POINTLESS_HLI_HLD_STEP1: '^(?:ld a, \[hl[-+id]\]|ld \[hl[-+id]\], a)$'
  CONTROL_FLOW_PREFIX: '^(jr|jp|jmp|call|rst|ret|predef)'
  WORD_HL: '.*\bhl\b'
  POINTLESS_JUMPS_STEP1: '^(jr|jp|jmp|jump|sjump|jumpchannel|sound_jump) '

  CP_OR_0_OR_AND_FF: '^(?:cp|or) [%$&]?0+$|^and (?:255|-1|\$[Ff][Ff]|%11111111|&377)$'
  CP_1: '^cp [%$&]?0*1$'
  JR_NZ: '^(jr|jp|jmp) nz,'
  LD_ANY_0: '^ld .+, [%$&]?0+$'
  LD_BCDE_IMM_NOT_HBD: '^ld (?:bc|de), [^hbd]'

  PREFIX_A: '^(?:rl|rlc|rr|rrc) a$'
  AND_OR_XOR: '^(?:and|or|xor) '
  AND_OR_A: '^(?:and a|or a|and a, a|or a, a)$'
  AFFECTS_ZC: '^(?:rlca|rrca|rla|rra|daa|pop af|add |adc |sub |sbc |and |or |xor |cp |rlc |rrc |rl |rr |sla |sra |swap |srl |ld hl, sp|ldhl sp)'

  CALL_RST_ADDNTIMES: '^(?:call|rst) AddNTimes'
  LD_WRAM_LOAD: '^ld a, \[w'
  LD_WRAM_STORE: '^ld \[w.*?\], a'
  LABEL_DEFINITION_TEXT_START: '^[A-Za-z_\\.]'
  TEXT_TRAILING_SPACE: '^(?:text|next1?|line|page|para|cont|prompt)\s*"[^"]* "'
  TEXT_COMMAND_FOLLOWS: '^(?:text_|sound_|start_asm|deciram|interpret_data|limited_interpret_data|link_wait_button|current_day|stop_compressing_text)'

  REPT_4_CI: '^(?i:rept 4)$'
  ENDR_CI: '^(?i:endr)$'

  LD_ANY_IMM_NOT_REG_OR_MEM: '^ld .+, [^afbcdehl\[]'

  LOAD_SRC_IS_SINGLE_REG: '^ldh? [^,]+,\s*[afbcdehl]\s*$'

  ADD_PAIR_THREE_STEP: '^add (?:hl|bc|de), (?!hl|bc|de)'

conditions:
  is_ld_or_ldh:
    code_starts_with_any: ['ld ', 'ldh ']

  label_definition_line:
    all:
      - { text_regex: LABEL_DEFINITION_TEXT_START }
      - not: { code_contains: ' ' }
      - not:
          any:
            - { code_eq: endc }
            - { code_eq: endr }
            - { code_eq: endm }

  # These symbols are not HRAM despite matching the broad [h|r] prefix heuristic.
  is_bank_reg_symbol:
    code_contains_any: [rROMB, rROMB0, rROMB1, rRAMG, rRAMB, rRTCLATCH, rRTCREG]

  volatile_operand:
    code_contains_any: ['[hli]', '[hld]', '[hl+]', '[hl-]', '[rJOYP]', '[rBGPD]', '[rOBPD]']

  # Used by the "= a * 16" patterns: `add xx, xx` must operate on the same pair
  # implied by the previous `ld` target (h/l, b/c, or d/e).
  mul16_add_pair_matches_prev_ld:
    any:
      - all:
          - { code_eq: 'add hl, hl' }
          - str_eq_in:
              left: { prev: { idx: 0, field: code }, byte_at: 3 }
              rights: ['h', 'l', 'H', 'L']
      - all:
          - { code_eq: 'add bc, bc' }
          - str_eq_in:
              left: { prev: { idx: 0, field: code }, byte_at: 3 }
              rights: ['b', 'c', 'B', 'C']
      - all:
          - { code_eq: 'add de, de' }
          - str_eq_in:
              left: { prev: { idx: 0, field: code }, byte_at: 3 }
              rights: ['d', 'e', 'D', 'E']

  # In the 3-step pair-add pattern, ensure the `add` operands match the previously
  # loaded pair registers.
  pair_add_three_step_matches_prev_pairs:
    all:
      - { regex: ADD_PAIR_THREE_STEP }
      - str_eq:
          left: { current: code, byte_at: 4 }
          right: { prev: { idx: 0, field: code }, byte_at: 3 }
      - str_eq:
          left: { current: code, byte_at: 8 }
          right: { prev: { idx: 1, field: code }, byte_at: 3 }

  # Middle "..." line for pair patterns: must not be a label or control-flow, and
  # must not touch the active pair via memory/stack (push/pop/[hl], etc.).
  pair_eq_n_gap_is_safe:
    all:
      - not: { regex: CONTROL_FLOW_PREFIX }
      - not:
          all:
            - str_eq: { left: { current: code, byte_at: 0 }, right: { prev: { idx: 0, field: code }, byte_at: 0 } }
            - str_eq: { left: { current: code, byte_at: 1 }, right: { prev: { idx: 0, field: code }, byte_at: 1 } }
            - str_eq: { left: { current: code, byte_at: 2 }, right: { prev: { idx: 0, field: code }, byte_at: 2 } }
            - str_eq: { left: { current: code, byte_at: 3 }, right: { prev: { idx: 0, field: code }, byte_at: 3 } }
            - str_eq: { left: { current: code, byte_at: 4 }, right: { prev: { idx: 0, field: code }, byte_at: 4 } }
      - not: { code_starts_with: '.' }
      - not: { code_ends_with: ':' }
      - any:
          - all:
              - str_eq: { left: { prev: { idx: 0, field: code }, byte_at: 3 }, right: { const: 'h' } }
              - str_eq: { left: { prev: { idx: 0, field: code }, byte_at: 4 }, right: { const: 'l' } }
              - not: { code_contains: '[hl' }
              - not: { code_starts_with: 'push hl' }
              - not: { code_starts_with: 'pop hl' }
          - all:
              - str_eq: { left: { prev: { idx: 0, field: code }, byte_at: 3 }, right: { const: 'b' } }
              - str_eq: { left: { prev: { idx: 0, field: code }, byte_at: 4 }, right: { const: 'c' } }
              - not: { code_contains: '[bc' }
              - not: { code_starts_with: 'push bc' }
              - not: { code_starts_with: 'pop bc' }
          - all:
              - str_eq: { left: { prev: { idx: 0, field: code }, byte_at: 3 }, right: { const: 'd' } }
              - str_eq: { left: { prev: { idx: 0, field: code }, byte_at: 4 }, right: { const: 'e' } }
              - not: { code_contains: '[de' }
              - not: { code_starts_with: 'push de' }
              - not: { code_starts_with: 'pop de' }

  pair_add_step2:
    any:
      - all:
          - str_eq_in:
              left: { prev: { idx: 0, field: code }, after_prefix: 'add a, ', byte_at: 0 }
              rights: ['l', 'c', 'e']
          - str_eq:
              left: { current: code, after_prefix: 'ld ', before_comma: true, trim: true }
              right: { prev: { idx: 0, field: code }, after_prefix: 'add a, ', byte_at: 0 }
      - all:
          - str_eq_in:
              left: { prev: { idx: 0, field: code }, after_prefix: 'add ', byte_at: 0 }
              rights: ['l', 'c', 'e']
          - str_eq:
              left: { current: code, after_prefix: 'ld ', before_comma: true, trim: true }
              right: { prev: { idx: 0, field: code }, after_prefix: 'add ', byte_at: 0 }
      - all:
          - not:
              any:
                - str_eq_in:
                    left: { prev: { idx: 0, field: code }, after_prefix: 'add a, ', byte_at: 0 }
                    rights: ['l', 'c', 'e']
                - str_eq_in:
                    left: { prev: { idx: 0, field: code }, after_prefix: 'add ', byte_at: 0 }
                    rights: ['l', 'c', 'e']

  pair_add_step3:
    any:
      - all:
          - str_eq_in:
              left: { current: code, after_prefix: 'ld a, ', trim: true }
              rights: ['h', 'b', 'd']
          - str_eq:
              left: { current: code, after_prefix: 'ld a, ', trim: true }
              right: { prev: { idx: 1, field: code }, after_prefix: 'ld ', before_comma: true, trim: true, pair_reg: true }
      - not:
          str_eq_in:
            left: { current: code, after_prefix: 'ld a, ', trim: true }
            rights: ['h', 'b', 'd']

  pair_add_step4:
    any:
      - all:
          - str_eq_in:
              left: { current: code, after_prefix: 'adc ', trim: true }
              rights: ['h', 'b', 'd']
          - str_eq:
              left: { current: code, after_prefix: 'adc ', trim: true }
              right: { prev: { idx: 1, field: code }, after_prefix: 'ld ', before_comma: true, trim: true, pair_reg: true }
      - not:
          str_eq_in:
            left: { current: code, after_prefix: 'adc ', trim: true }
            rights: ['h', 'b', 'd']

  pair_add_step5:
    str_eq:
      left: { current: code, after_prefix: 'ld ', before_comma: true, trim: true }
      right: { prev: { idx: 1, field: code }, after_prefix: 'ld ', before_comma: true, trim: true, pair_reg: true }

  pair_add_jump_step4:
    str_eq:
      left: { current: code, after_prefix: 'inc ', trim: true }
      right: { prev: { idx: 1, field: code }, after_prefix: 'ld ', before_comma: true, trim: true, pair_reg: true }

  reg_conditional_ternary_step5:
    any:
      - { regex: LDH_R }
      - all:
          - code_in: ['xor a', 'xor a, a']
          - any:
              - str_eq:
                  left: { prev: { idx: 1, field: code }, after_prefix: 'ld ', before_comma: true, trim: true }
                  right: { const: 'a' }
              - str_eq:
                  left: { prev: { idx: 1, field: code }, after_prefix: 'ldh ', before_comma: true, trim: true }
                  right: { const: 'a' }

  reg_conditional_ternary_step6:
    any:
      - str_eq:
          left: { current: code }
          right: { prev: { idx: 2, field: code } }
      - str_eq:
          left: { current: code, strip_trailing_colon: true }
          right: { prev: { idx: 2, field: code }, last_token: true }

  pair_eq_deref_foo_step3:
    all:
      - not:
          str_eq:
            left: { prev: { idx: 0, field: code }, after_prefix: 'ld a, [', symbol_like: true }
            right: { const: '' }
      - str_eq:
          left: { prev: { idx: 0, field: code }, after_prefix: 'ld a, [', symbol_like: true }
          right: { current: code, after_prefix: 'ld a, [', symbol_like: true }

patterns:
  py_redundant_arguments:
    name: Redundant arguments
    steps:
      - regex: REDUNDANT_ARGUMENTS

  py_nops:
    name: nops
    steps:
      - code_ne: halt
      - code_eq: nop

  py_no_op_ld:
    name: No-op ld
    steps:
      - regex: NO_OP_LD_PY

  py_no_op_add_sub:
    name: No-op add|sub
    steps:
      - regex: NO_OP_ADD_SUB

  py_inefficient_hram_load:
    name: Inefficient HRAM load
    steps:
      - all:
          - { regex: INEFFICIENT_HRAM_LOAD }
          - not: is_bank_reg_symbol

  py_inefficient_hram_store:
    name: Inefficient HRAM store
    steps:
      - all:
          - { regex: INEFFICIENT_HRAM_STORE }
          - { code_ends_with: ', a' }
          - not: is_bank_reg_symbol

  py_a_eq_0:
    name: a = 0
    steps:
      - regex: A_EQ_0

  py_a_inc_dec:
    name: a++|a--
    steps:
      - regex: A_INC_DEC

  py_a_times_2:
    name: a *= 2
    steps:
      - code_eq: 'sla a'

  py_a_not:
    name: a = ~a
    steps:
      - regex: A_NOT

  py_a_eq_n_minus_a:
    name: a = N - a
    steps:
      - regex: LD_R_A
      - regex: LD_A_IMM
      - all:
          - { regex: SUB_R }
          - str_eq:
              left:
                current: code
                after_prefix: 'sub '
                trim: true
              right:
                prev: { idx: 0, field: code }
                after_prefix: 'ld '
                before_comma: true
                trim: true

  py_a_eq_carry_pq:
    name: 'a = carry ? P : Q'
    steps:
      - regex: LD_A_IMM
      - regex: JUMP_NC_OR_C
      - any:
          - { regex: LD_A_IMM }
          - { code_eq: 'xor a' }
          - { code_eq: 'inc a' }
          - { code_eq: 'dec a' }
      - str_eq:
          left: { current: code, strip_trailing_colon: true }
          right:
            prev: { idx: 1, field: code }
            after_comma: true
            trim: true

  py_a_inc_dec_if_carry:
    name: a++|a-- if carry
    steps:
      - regex: JUMP_NC
      - code_in: ['inc a', 'dec a']
      - rewind: 1
        when:
          str_eq:
            left: { current: code, strip_trailing_colon: true }
            right:
              prev: { idx: 0, field: code }
              after_comma: true
              trim: true

  py_a_inc_dec_if_not_carry:
    name: a++|a-- if not carry
    steps:
      - regex: JUMP_C
      - code_in: ['inc a', 'dec a']
      - rewind: 1
        when:
          str_eq:
            left: { current: code, strip_trailing_colon: true }
            right:
              prev: { idx: 0, field: code }
              after_comma: true
              trim: true

  py_a_shift_right_3:
    name: a = a >> 3
    steps:
      - regex: SRL_A
      - regex: SRL_A
      - regex: SRL_A

  py_a_eq_x_plusminus_carry:
    name: a = X +/- carry
    steps:
      - regex: LD_DST_A
      - all:
          - { code_starts_with: 'ld a,' }
          - any:
              - not: { code_starts_with: 'ld a, [' }
              - { code_eq: 'ld a, [hl]' }
      - regex: ADC_SBC_0

  py_a_eq_carry_plusminus_x:
    name: a = carry +/- X
    steps:
      - regex: LD_DST_A
      - regex: LD_A_0
      - any:
          - all:
              - code_starts_with: 'adc '
              - any:
                  - not: { code_starts_with: 'adc [' }
                  - code_eq: 'adc [hl]'
          - all:
              - code_starts_with: 'sbc '
              - any:
                  - not: { code_starts_with: 'sbc [' }
                  - code_eq: 'sbc [hl]'

  py_reg_conditional_ternary:
    name: 'a|b|c|d|e|h|l = z|nz|c|nc ? P : Q'
    steps:
      - regex: JUMP_NZ_OR_ZC
      - regex: LDH_R
      - all:
          - { regex: JR_JP_JMP_ANY }
          - not: { code_contains: ',' }
          - { code_ne: 'jp hl' }
      - str_eq:
          left: { current: code, strip_trailing_colon: true }
          right:
            prev: { idx: 0, field: code }
            after_comma: true
            trim: true
      - reg_conditional_ternary_step5
      - reg_conditional_ternary_step6

  py_a_and_x_eq_x:
    name: a & X == X
    steps:
      - regex: AND_IMM
      - all:
          - { regex: CP_IMM }
          - str_eq:
              left:
                current: code
                after_prefix: 'cp '
              right:
                prev: { idx: 0, field: code }
                after_prefix: 'and '

  py_a_mask_or:
    name: a = (a & MASK) | (b|c|d|e|h|l & ~MASK)
    steps:
      - regex: AND_IMM
      - regex: LD_RH_A
      - all:
          - { regex: LD_A_RH }
          - not:
              str_eq:
                left:
                  current: code
                  after_comma: true
                  trim: true
                right:
                  prev: { idx: 1, field: code }
                  after_prefix: 'ld '
                  before_comma: true
                  trim: true
      - regex: AND_IMM
      - all:
          - { regex: OR_R }
          - str_eq:
              left:
                current: code
                last_token: true
                trim: true
              right:
                prev: { idx: 1, field: code }
                after_prefix: 'ld '
                before_comma: true
                trim: true

  py_pair_add_a_or_n:
    name: hl|bc|de += a|N
    steps:
      - regex: ADD_A_LCE_OR_IMM
      - all:
          - regex: LD_LCE_A
          - pair_add_step2
      - all:
          - regex: LD_A_HBD_OR_0
          - pair_add_step3
      - all:
          - regex: ADC_HBD_OR_0
          - pair_add_step4
      - all:
          - regex: LD_HBD_A
          - pair_add_step5

  py_pair_add_a_or_n_jump:
    name: hl|bc|de += a|N (jump)
    steps:
      - regex: ADD_A_LCE_OR_IMM
      - all:
          - regex: LD_LCE_A
          - pair_add_step2
      - regex: JUMP_NC
      - all:
          - code_starts_with: 'inc '
          - pair_add_jump_step4
      - str_eq:
          left: { current: code, strip_trailing_colon: true }
          right:
            prev: { idx: 2, field: code }
            after_comma: true
            trim: true

  py_pair_eq_foo_plus_a:
    name: hl|bc|de = Foo + a
    steps:
      - regex: LD_PAIR_IMM
      - all:
          - regex: ADD_LCE
          - str_eq:
              left: { current: code, last_char: true }
              right: { prev: { idx: 0, field: code }, byte_at: 4 }
      - all:
          - regex: LD_LCE_A
          - str_eq:
              left: { current: code, byte_at: 3 }
              right: { prev: { idx: 0, field: code }, byte_at: 4 }
      - all:
          - regex: ADC_HBD
          - str_eq:
              left: { current: code, last_char: true }
              right: { prev: { idx: 0, field: code }, byte_at: 3 }
      - all:
          - regex: SUB_LCE
          - str_eq:
              left: { current: code, last_char: true }
              right: { prev: { idx: 0, field: code }, byte_at: 4 }
      - all:
          - regex: LD_HBD_A
          - str_eq:
              left: { current: code, byte_at: 3 }
              right: { prev: { idx: 0, field: code }, byte_at: 3 }

  py_reg_plus_carry:
    name: b|c|d|e|h|l += carry
    steps:
      - regex: LD_A_BCDEHL_OR_0
      - regex: ADC_BCDEHL_OR_0
      - all:
          - { regex: LD_RH_A }
          - any:
              - str_eq:
                  left:
                    current: code
                    byte_at: 3
                  right:
                    prev: { idx: 0, field: code }
                    byte_at: 6
              - str_eq:
                  left:
                    current: code
                    byte_at: 3
                  right:
                    prev: { idx: 1, field: code }
                    byte_at: 4
          - any:
              - str_eq:
                  left:
                    prev: { idx: 0, field: code }
                    last_char: true
                  right: { const: '0' }
              - str_eq:
                  left:
                    prev: { idx: 1, field: code }
                    last_char: true
                  right: { const: '0' }

  py_reg_minus_carry:
    name: b|c|d|e|h|l -= carry
    steps:
      - regex: LD_A_BCDEHL_OR_0
      - regex: SBC_BCDEHL_OR_0
      - all:
          - { regex: LD_RH_A }
          - any:
              - str_eq:
                  left:
                    current: code
                    byte_at: 3
                  right:
                    prev: { idx: 0, field: code }
                    byte_at: 6
              - str_eq:
                  left:
                    current: code
                    byte_at: 3
                  right:
                    prev: { idx: 1, field: code }
                    byte_at: 4
          - any:
              - str_eq:
                  left:
                    prev: { idx: 0, field: code }
                    last_char: true
                  right: { const: '0' }
              - str_eq:
                  left:
                    prev: { idx: 1, field: code }
                    last_char: true
                  right: { const: '0' }

  py_pair_eq_a_mul_16:
    name: hl|bc|de = a * 16
    steps:
      - regex_in: [LD_LCE_A, LD_HBD_0]
      - all:
          - regex_in: [LD_LCE_A, LD_HBD_0]
          - not:
              str_eq:
                left: { current: code }
                right: { prev: { idx: 0, field: code } }
          - str_eq:
              left:
                current: code
                after_prefix: 'ld '
                before_comma: true
                trim: true
              right:
                prev: { idx: 0, field: code }
                after_prefix: 'ld '
                before_comma: true
                trim: true
                pair_reg: true
      - mul16_add_pair_matches_prev_ld
      - mul16_add_pair_matches_prev_ld
      - mul16_add_pair_matches_prev_ld
      - mul16_add_pair_matches_prev_ld

  py_pair_eq_a_mul_16_rept:
    name: hl|bc|de = a * 16 (rept)
    steps:
      - regex_in: [LD_LCE_A, LD_HBD_0]
      - all:
          - regex_in: [LD_LCE_A, LD_HBD_0]
          - not:
              str_eq:
                left: { current: code }
                right: { prev: { idx: 0, field: code } }
          - str_eq:
              left:
                current: code
                after_prefix: 'ld '
                before_comma: true
                trim: true
              right:
                prev: { idx: 0, field: code }
                after_prefix: 'ld '
                before_comma: true
                trim: true
                pair_reg: true
      - regex: REPT_4_CI
      - mul16_add_pair_matches_prev_ld
      - regex: ENDR_CI

  py_hl_mul_2:
    name: hl *= 2
    steps:
      - code_eq: 'sla l'
      - code_eq: 'rl h'

  py_pair_eq_deref_foo:
    name: hl = *Foo
    steps:
      - regex: LD_A_MEM_NOT_HBD
      - regex: LD_LH_A
      - all:
          - { regex: LD_A_MEM_NOT_HBD }
          - pair_eq_deref_foo_step3
      - all:
          - { regex: LD_LH_A }
          - not:
              str_eq:
                left:
                  current: code
                  after_prefix: 'ld '
                  before_comma: true
                  trim: true
                right:
                  prev: { idx: 1, field: code }
                  after_prefix: 'ld '
                  before_comma: true
                  trim: true

  py_pair_load_pq:
    name: h,l|b,c|d,e = P,Q
    steps:
      - regex: LD_R_IMM
      - all:
          - { regex: LD_R_IMM }
          - str_eq:
              left: { current: context }
              right: { prev: { idx: 0, field: context } }
          - str_eq:
              left:
                current: code
                after_prefix: 'ld '
                before_comma: true
                trim: true
              right:
                prev: { idx: 0, field: code }
                after_prefix: 'ld '
                before_comma: true
                trim: true
                pair_reg: true

  py_deref_hl_eq_n:
    name: '*hl = N'
    steps:
      - regex: LD_A_IMM
      - code_eq: 'ld [hl], a'

  py_deref_hl_inc_dec:
    name: '*hl++|*hl--'
    steps:
      - code_eq: 'ld a, [hl]'
      - code_in: ['inc a', 'dec a']
      - rewind: 1
        when: { code_eq: 'ld [hl], a' }

  py_deref_hl_inc_dec_eq_a:
    name: '*hl++|*hl-- = a'
    steps:
      - code_eq: 'ld [hl], a'
      - code_in: ['inc hl', 'dec hl']

  py_deref_hl_inc_dec_eq_n:
    name: '*hl++|*hl-- = N'
    steps:
      - regex: LD_MEMHL_IMM
      - code_in: ['inc hl', 'dec hl']

  py_a_eq_deref_hl_inc_dec:
    name: 'a = *hl++|*hl--'
    steps:
      - code_eq: 'ld a, [hl]'
      - code_in: ['inc hl', 'dec hl']

  py_deref_hl_inc_dec_eq_r:
    name: '*hl++|*hl-- = b|c|d|e'
    steps:
      - regex: LD_MEMHL_R
      - code_in: ['inc hl', 'dec hl']

  py_r_eq_deref_hl_inc_dec:
    name: 'b|c|d|e = *hl++|*hl--'
    steps:
      - regex: LD_R_MEMHL
      - code_in: ['inc hl', 'dec hl']

  py_a_eq_0_cmp:
    name: a == 0
    steps:
      - regex: CP_OR_0_OR_AND_FF

  py_a_eq_1_cmp:
    name: a == 1
    steps:
      - regex: CP_1

  py_ei_ret:
    name: ei + ret
    steps:
      - code_eq: ei
      - code_eq: ret

  py_tail_call:
    name: Tail call
    steps:
      - all:
          - { code_starts_with: 'call ' }
          - not: { code_contains: ',' }
      - code_eq: ret

  py_tail_farcall:
    name: Tail farcall
    steps:
      - all:
          - { code_starts_with: 'farcall ' }
          - not: { code_contains: ',' }
      - code_eq: ret

  py_tail_predef:
    name: Tail predef
    steps:
      - code_starts_with: 'predef '
      - code_eq: ret

  py_fallthrough:
    name: Fallthrough
    steps:
      - all:
          - { code_starts_with: 'call ' }
          - not: { code_contains: ',' }
      - code_eq: ret
      - str_eq:
          left: { current: code, strip_trailing_colon: true }
          right:
            prev: { idx: 0, field: code }
            after_prefix: 'call '
            trim: true

  py_conditional_call:
    name: Conditional call
    steps:
      - regex: JUMP_NZ_OR_ZC
      - all:
          - { code_starts_with: 'call ' }
          - not: { code_contains: ',' }
      - any:
          - all:
              - { regex: JR_JP_JMP_ANY }
              - not: { code_contains: ',' }
              - str_eq:
                  left:
                    current: code
                    last_token: true
                  right:
                    prev: { idx: 0, field: code }
                    after_comma: true
                    trim: true
          - str_eq:
              left: { current: code, strip_trailing_colon: true }
              right:
                prev: { idx: 0, field: code }
                after_comma: true
                trim: true

  py_conditional_return:
    name: Conditional return
    steps:
      - regex: JUMP_NZ_OR_ZC
      - code_eq: ret
      - str_eq:
          left: { current: code, strip_trailing_colon: true }
          right:
            prev: { idx: 0, field: code }
            after_comma: true
            trim: true

  py_conditional_fallthrough:
    name: Conditional fallthrough
    steps:
      - regex: JUMP_NZ_OR_ZC
      - all:
          - { regex: JR_JP_JMP_ANY }
          - not: { code_contains: ',' }
          - { code_ne: 'jp hl' }
      - str_eq:
          left: { current: code, strip_trailing_colon: true }
          right:
            prev: { idx: 0, field: code }
            after_comma: true
            trim: true

  py_call_hl:
    name: call hl
    steps:
      - regex: LD_BCDE_IMM_NOT_HBD
      - all:
          - any:
              - code_in: ['push bc', 'push de']
          - str_eq:
              left:
                current: code
                after_prefix: 'push '
                trim: true
              right:
                prev: { idx: 0, field: code }
                after_prefix: 'ld '
                before_comma: true
                trim: true
      - code_eq: 'jp hl'
      - str_eq:
          left: { current: code, strip_trailing_colon: true }
          right:
            prev: { idx: 0, field: code }
            after_comma: true
            trim: true

  py_pointless_hli_hld:
    name: Pointless hli|hld
    steps:
      - regex: POINTLESS_HLI_HLD_STEP1
      - rewind: 1
        when:
          all:
            - not: { regex: CONTROL_FLOW_PREFIX }
            - not: { regex: WORD_HL }
      - regex: LD_HL_IMM_OR_POP_HL

  py_pointless_jumps:
    name: Pointless jumps
    steps:
      - all:
          - { regex: POINTLESS_JUMPS_STEP1 }
          - not: { code_contains: ',' }
      - all:
          - str_eq:
              left: { current: code, strip_trailing_colon: true }
              right:
                prev: { idx: 0, field: code }
                last_token: true
          - any:
              - str_eq:
                  left: { current: context }
                  right: { prev: { idx: 0, field: context } }
              - str_eq:
                  left: { current: context }
                  right: { current: code }

  py_useless_loads:
    name: Useless loads
    steps:
      - all:
          - is_ld_or_ldh
          - { code_contains: ',' }
          - not: volatile_operand
      - all:
          - is_ld_or_ldh
          - { code_contains: ',' }
          - not:
              any:
                - { code_eq: 'ld h, [hl]' }
                - { code_eq: 'ld l, [hl]' }
          - str_eq:
              left:
                current: code
                before_comma: true
              right:
                prev: { idx: 0, field: code }
                before_comma: true

  py_redundant_loads:
    name: Redundant loads
    steps:
      - all:
          - is_ld_or_ldh
          - { code_contains: ',' }
          - not: volatile_operand
      - all:
          - is_ld_or_ldh
          - { code_contains: ',' }
          - str_eq:
              left: { current: context }
              right: { prev: { idx: 0, field: context } }
          - str_eq:
              left:
                current: code
                after_prefix: 'ld'
                before_comma: true
                last_token: true
                trim: true
              right:
                prev: { idx: 0, field: code }
                after_comma: true
                trim: true
          - str_eq:
              left:
                current: code
                after_comma: true
                trim: true
              right:
                prev: { idx: 0, field: code }
                after_prefix: 'ld'
                before_comma: true
                last_token: true
                trim: true

  py_similar_loads:
    name: Similar loads
    steps:
      - all:
          - is_ld_or_ldh
          - { code_contains: ',' }
          - not: { regex: LOAD_SRC_IS_SINGLE_REG }
          - not: volatile_operand
      - all:
          - { code_starts_with: 'ld a,' }
          - str_eq:
              left:
                current: code
                after_comma_raw: true
              right:
                prev: { idx: 0, field: code }
                after_comma_raw: true

  py_conditionally_load_0:
    name: Conditionally load 0
    steps:
      - any:
          - { code_starts_with: 'and ' }
          - { code_starts_with: 'or ' }
      - regex: JR_NZ
      - regex: LD_ANY_0

  py_inefficient_prefix_opcodes:
    name: Inefficient prefix opcodes
    steps:
      - regex: PREFIX_A

  py_redundant_and_or:
    name: Redundant and|or
    steps:
      - regex: AND_OR_XOR
      - regex: AND_OR_A

  py_pointless_and_or_a:
    name: Pointless and|or a
    steps:
      - regex: AND_OR_A
      - regex: AFFECTS_ZC

  py_redundant_inc_dec:
    name: Redundant inc|dec
    steps:
      - regex: LD_ANY_IMM_NOT_REG_OR_MEM
      - any:
          - all:
              - { code_starts_with: 'inc ' }
              - str_eq:
                  left:
                    current: code
                    after_prefix: 'inc '
                    trim: true
                  right:
                    prev: { idx: 0, field: code }
                    before_comma: true
                    strip_prefix: 'ld'
                    trim: true
          - all:
              - { code_starts_with: 'dec ' }
              - str_eq:
                  left:
                    current: code
                    after_prefix: 'dec '
                    trim: true
                  right:
                    prev: { idx: 0, field: code }
                    before_comma: true
                    strip_prefix: 'ld'
                    trim: true

  py_pair_eq_n_then_other_then_add:
    name: hl|bc|de = N / bc|de|hl = K / hl|bc|de += bc|de|hl
    steps:
      - regex: LD_PAIR_IMM
      - all:
          - { regex: LD_PAIR_IMM }
          - not:
              str_eq:
                left:
                  current: code
                  byte_at: 2
                right:
                  prev: { idx: 0, field: code }
                  byte_at: 3
      - rewind: 1
        when:
          all:
            - { regex: ADD_PAIR_THREE_STEP }
            - str_eq:
                left:
                  current: code
                  byte_at: 4
                right:
                  prev: { idx: 0, field: code }
                  byte_at: 3
            - str_eq:
                left:
                  current: code
                  byte_at: 8
                right:
                  prev: { idx: 1, field: code }
                  byte_at: 3

  py_pair_eq_n_then_inc_dec:
    name: hl|bc|de = N / ... / inc|dec hl|bc|de
    steps:
      - regex: LD_PAIR_IMM
      - rewind: 1
        when: pair_eq_n_gap_is_safe
      - rewind: 1
        when:
          any:
            - all:
                - { code_starts_with: 'inc ' }
                - str_eq:
                    left:
                      current: code
                      after_prefix: 'inc '
                      trim: true
                    right:
                      prev: { idx: 0, field: code }
                      after_prefix: 'ld '
                      before_comma: true
                      trim: true
            - all:
                - { code_starts_with: 'dec ' }
                - str_eq:
                    left:
                      current: code
                      after_prefix: 'dec '
                      trim: true
                    right:
                      prev: { idx: 0, field: code }
                      after_prefix: 'ld '
                      before_comma: true
                      trim: true

  py_pair_eq_n_and_other_add:
    name: hl|bc|de = N / ... / bc|de|hl = K / hl|bc|de += bc|de|hl
    steps:
      - regex: LD_PAIR_IMM
      - rewind: 1
        when: pair_eq_n_gap_is_safe
      - regex: LD_PAIR_IMM
      - rewind: 1
        when: pair_add_three_step_matches_prev_pairs

  py_dec_a_then_addntimes:
    name: dec a, then AddNTimes
    steps:
      - regex: LD_HL_IMM
      - any:
          - { regex: LD_BC_IMM }
          - { code_eq: 'dec a' }
      - all:
          - any:
              - { regex: LD_BC_IMM }
              - { code_eq: 'dec a' }
          - any:
              - all:
                  - str_eq:
                      left: { current: code }
                      right: { const: 'dec a' }
                  - not:
                      str_eq:
                        left: { prev: { idx: 1, field: code } }
                        right: { const: 'dec a' }
              - all:
                  - not:
                      str_eq:
                        left: { current: code }
                        right: { const: 'dec a' }
                  - str_eq:
                      left: { prev: { idx: 1, field: code } }
                      right: { const: 'dec a' }
      - regex: CALL_RST_ADDNTIMES

  py_redundant_ret:
    name: Redundant ret
    steps:
      - any:
          - { code_eq: ret }
          - { code_starts_with: 'ret ' }
      - any:
          - { code_eq: ret }
          - all:
              - { code_starts_with: 'ret ' }
              - any:
                  - str_eq:
                      left: { prev: { idx: 0, field: code } }
                      right: { const: 'ret' }
                  - str_eq:
                      left:
                        current: code
                        last_char: true
                      right:
                        prev: { idx: 0, field: code }
                        last_char: true

  py_stub_function:
    name: Stub function
    steps:
      - label_definition_line
      - code_eq: ret

  py_stub_jump:
    name: Stub jump
    steps:
      - label_definition_line
      - all:
          - { code_starts_with: 'jr ' }
          - not: { code_contains: ',' }

  py_wram_inc_dec:
    name: Inefficient WRAM increment/decrement
    steps:
      - regex: LD_WRAM_LOAD
      - code_in: ['inc a', 'dec a']
      - all:
          - { regex: LD_WRAM_STORE }
          - str_eq:
              left:
                current: code
                before_comma: true
                strip_prefix: 'ld '
                trim: true
              right:
                prev: { idx: 0, field: code }
                after_comma: true
                trim: true

  py_trailing_string_space:
    name: Trailing string space
    steps:
      - regex: TEXT_TRAILING_SPACE
      - not: { regex: TEXT_COMMAND_FOLLOWS }

  no_op_add_sub:
    name: No-op add|sub
    steps:
      - any:
          - instruction:
              mnemonic: add
              operands:
                - { is_zero_literal: true }
          - instruction:
              mnemonic: sub
              operands:
                - { is_zero_literal: true }
          - instruction:
              mnemonic: add
              operands:
                - { eq: a }
                - { is_zero_literal: true }
          - instruction:
              mnemonic: sub
              operands:
                - { eq: a }
                - { is_zero_literal: true }

  ld_a_from_hli:
    name: Load a from [hli]/[hl+]
    steps:
      - instruction:
          mnemonic: ld
          operands:
            - { eq: a }
            - { canon_eq: '[hli]' }

packs:
  core:
    patterns:
      - py_no_op_ld
      - no_op_add_sub
      - ld_a_from_hli

  rgbds:
    patterns:
      - py_redundant_arguments
      - py_nops
      - py_no_op_ld
      - no_op_add_sub
      - py_a_eq_0
      - py_a_inc_dec
      - py_a_times_2
      - py_a_not
      - ld_a_from_hli

  pret:
    patterns:
      - py_redundant_arguments
      - py_nops
      - py_no_op_ld
      - py_no_op_add_sub
      - py_inefficient_hram_load
      - py_inefficient_hram_store
      - py_a_eq_0
      - py_a_inc_dec
      - py_a_times_2
      - py_a_not
      - py_a_eq_n_minus_a
      - py_a_eq_carry_pq
      - py_a_inc_dec_if_carry
      - py_a_inc_dec_if_not_carry
      - py_a_shift_right_3
      - py_a_eq_x_plusminus_carry
      - py_a_eq_carry_plusminus_x
      - py_reg_conditional_ternary
      - py_a_and_x_eq_x
      - py_a_mask_or
      - py_pair_add_a_or_n
      - py_pair_add_a_or_n_jump
      - py_pair_eq_foo_plus_a
      - py_reg_plus_carry
      - py_reg_minus_carry
      - py_pair_eq_a_mul_16
      - py_pair_eq_a_mul_16_rept
      - py_hl_mul_2
      - py_pair_eq_deref_foo
      - py_pair_load_pq
      - py_deref_hl_eq_n
      - py_deref_hl_inc_dec
      - py_deref_hl_inc_dec_eq_a
      - py_deref_hl_inc_dec_eq_n
      - py_a_eq_deref_hl_inc_dec
      - py_deref_hl_inc_dec_eq_r
      - py_r_eq_deref_hl_inc_dec
      - py_a_eq_0_cmp
      - py_a_eq_1_cmp
      - py_ei_ret
      - py_tail_call
      - py_tail_farcall
      - py_tail_predef
      - py_fallthrough
      - py_conditional_call
      - py_conditional_return
      - py_conditional_fallthrough
      - py_call_hl
      - py_pointless_hli_hld
      - py_pointless_jumps
      - py_useless_loads
      - py_redundant_loads
      - py_similar_loads
      - py_conditionally_load_0
      - py_inefficient_prefix_opcodes
      - py_redundant_and_or
      - py_pointless_and_or_a
      - py_redundant_inc_dec
      - py_pair_eq_n_then_other_then_add
      - py_pair_eq_n_then_inc_dec
      - py_pair_eq_n_and_other_add
      - py_dec_a_then_addntimes
      - py_redundant_ret
      - py_stub_function
      - py_stub_jump
      - py_wram_inc_dec
      - py_trailing_string_space
