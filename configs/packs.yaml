# Runtime-loaded optimization definitions.
# This file is intentionally user-editable; regexes are compiled once at startup.

regexes:
  NO_OP_LD_PY: '^ld ([abcdehl]), \1$'
  NO_OP_ADD_SUB: '^(?:add|sub) (?:a, )?(?:[%$&]?0+|FALSE)$'
  INEFFICIENT_HRAM_LOAD: '^ld a, \[[hr][^l]'
  INEFFICIENT_HRAM_STORE: '^ld \[[hr][^l]'
  A_EQ_0: '^ld a, (?:[%$&]?0+|FALSE)$'
  A_INC_DEC: '^(?:add|sub) (?:a, )?[%$&]?0*1$'
  A_NOT: '^xor (?:255|-[%$&]?0*1|\$[Ff][Ff]|%11111111|&377)$'
  LD_R_A: '^ld [bcdehl], a'
  LD_A_IMM: '^ld a, [^afbcdehl\[]'
  SUB_R: '^sub [bcdehl]'
  JUMP_NC: '^(jr|jp|jmp) nc,'
  JUMP_C: '^(jr|jp|jmp) c,'
  JUMP_NC_OR_C: '^(jr|jp|jmp) n?c,'
  JUMP_NZ_OR_ZC: '^(jr|jp|jmp) n?[zc],'
  JR_JP_JMP_ANY: '^(jr|jp|jmp) '
  SRL_A: '^srl a$'
  LD_DST_A: '^ld ([bcdehl]|\[hl\]), a'
  ADC_SBC_0: '^(adc|sbc) [%$&]?0+$'
  LD_A_0: '^ld a, [%$&]?0+$'
  AND_IMM: '^and (?:a, )?[^afbcdehl\[]'
  CP_IMM: '^cp (?:a, )?[^afbcdehl\[]'
  LD_RH_A: '^ld [bcdehl], a$'
  LD_A_RH: '^ld a, [bcdehl]$'
  OR_R: '^or (?:a, )?[bcdehl]$'
  LDH_R: '^ldh? [abcdehl],'

  ADD_A_LCE_OR_IMM: '^add (?:a, )?(?:[lce]|[^afbdh\[])'
  LD_LCE_A: '^ld [lce], a'
  LD_A_HBD_OR_0: '^ld a, (?:[hbd]|[%$&]?0+$)'
  LD_A_BCDEHL_OR_0: '^ld a, (?:[bcdehl]|[%$&]?0+$)'
  ADC_BCDEHL_OR_0: '^adc (?:[bcdehl]|[%$&]?0+$)'
  SBC_BCDEHL_OR_0: '^sbc (?:[bcdehl]|[%$&]?0+$)'
  ADC_HBD_OR_0: '^adc (?:[hbd]|[%$&]?0+$)'
  LD_HBD_A: '^ld [hbd], a'
  LD_HBD_0: '^ld [hbd], [%$&]?0+$'

  LD_PAIR_IMM: '^ld (?:hl|bc|de), [^\[]'
  ADD_LCE: '^add (?:a, )?(?:[lce])$'
  ADC_HBD: '^adc (?:a, )?(?:[hbd])$'
  SUB_LCE: '^sub (?:a, )?(?:[lce])$'
  LD_A_MEM_NOT_HBD: '^ld a, \[[^hbd]'
  LD_LH_A: '^ld [lh], a$'

  LD_MEMHL_IMM: '^ld \[hl\], [^afbcdehl\[]'
  LD_MEMHL_R: '^ld \[hl\], [bcdehl]$'
  LD_R_MEMHL: '^ld [bcde], \[hl\]$'

  LD_R_IMM: '^ld [bcdehl], [^afbcdehl\[]'
  LD_HL_IMM: '^ld hl, [^\[]'
  LD_BC_IMM: '^ld bc, [^\[]'
  LD_HL_IMM_OR_POP_HL: '^(?:ld hl,|pop hl)'

  POINTLESS_HLI_HLD_STEP1: '^(?:ld a, \[hl[-+id]\]|ld \[hl[-+id]\], a)$'
  CONTROL_FLOW_PREFIX: '^(jr|jp|jmp|call|rst|ret|predef)'
  WORD_HL: '.*\bhl\b'
  POINTLESS_JUMPS_STEP1: '^(jr|jp|jmp|jump|sjump|jumpchannel|sound_jump) '

  CP_OR_0_OR_AND_FF: '^(?:cp|or) [%$&]?0+$|^and (?:255|-1|\$[Ff][Ff]|%11111111|&377)$'
  CP_1: '^cp [%$&]?0*1$'
  JR_NZ: '^(jr|jp|jmp) nz,'
  LD_ANY_0: '^ld .+, [%$&]?0+$'
  LD_BCDE_IMM_NOT_HBD: '^ld (?:bc|de), [^hbd]'

  PREFIX_A: '^(?:rl|rlc|rr|rrc) a$'
  AND_OR_XOR: '^(?:and|or|xor) '
  AND_OR_A: '^(?:and a|or a|and a, a|or a, a)$'
  AFFECTS_ZC: '^(?:rlca|rrca|rla|rra|daa|pop af|add |adc |sub |sbc |and |or |xor |cp |rlc |rrc |rl |rr |sla |sra |swap |srl |ld hl, sp|ldhl sp)'

  CALL_RST_ADDNTIMES: '^(?:call|rst) AddNTimes'
  LD_WRAM_LOAD: '^ld a, \[w'
  LD_WRAM_STORE: '^ld \[w.*?\], a'
  LABEL_DEFINITION_TEXT_START: '^[A-Za-z_\\.]'
  TEXT_TRAILING_SPACE: '^(?:text|next1?|line|page|para|cont|prompt)\s*"[^"]* "'
  TEXT_COMMAND_FOLLOWS: '^(?:text_|sound_|start_asm|deciram|interpret_data|limited_interpret_data|link_wait_button|current_day|stop_compressing_text)'

  REPT_4_CI: '^(?i:rept 4)$'
  ENDR_CI: '^(?i:endr)$'

  LD_ANY_IMM_NOT_REG_OR_MEM: '^ld .+, [^afbcdehl\[]'

  LOAD_SRC_IS_SINGLE_REG: '^ldh? [^,]+,\s*[afbcdehl]\s*$'

  ADD_PAIR_THREE_STEP: '^add (?:hl|bc|de), (?!hl|bc|de)'

conditions:
  is_ld_or_ldh:
    code_starts_with_any: ['ld ', 'ldh ']

  label_definition_line:
    all:
      - { text_regex: LABEL_DEFINITION_TEXT_START }
      - not: { code_contains: ' ' }
      - not:
          any:
            - { code_eq: endc }
            - { code_eq: endr }
            - { code_eq: endm }

  # These symbols are not HRAM despite matching the broad [h|r] prefix heuristic.
  is_bank_reg_symbol:
    code_contains_any: [rROMB, rROMB0, rROMB1, rRAMG, rRAMB, rRTCLATCH, rRTCREG]

  volatile_operand:
    code_contains_any: ['[hli]', '[hld]', '[hl+]', '[hl-]', '[rJOYP]', '[rBGPD]', '[rOBPD]']

  # Used by the "= a * 16" patterns: `add xx, xx` must operate on the same pair
  # implied by the previous `ld` target (h/l, b/c, or d/e).
  mul16_add_pair_matches_prev_ld:
    any:
      - all:
          - { code_eq: 'add hl, hl' }
          - str_eq_in:
              left: { prev: { idx: 0, field: code }, byte_at: 3 }
              rights: ['h', 'l', 'H', 'L']
      - all:
          - { code_eq: 'add bc, bc' }
          - str_eq_in:
              left: { prev: { idx: 0, field: code }, byte_at: 3 }
              rights: ['b', 'c', 'B', 'C']
      - all:
          - { code_eq: 'add de, de' }
          - str_eq_in:
              left: { prev: { idx: 0, field: code }, byte_at: 3 }
              rights: ['d', 'e', 'D', 'E']

  # In the 3-step pair-add pattern, ensure the `add` operands match the previously
  # loaded pair registers.
  pair_add_three_step_matches_prev_pairs:
    all:
      - { regex: ADD_PAIR_THREE_STEP }
      - str_eq:
          left: { current: code, byte_at: 4 }
          right: { prev: { idx: 0, field: code }, byte_at: 3 }
      - str_eq:
          left: { current: code, byte_at: 8 }
          right: { prev: { idx: 1, field: code }, byte_at: 3 }

  # Middle "..." line for pair patterns: must not be a label or control-flow, and
  # must not touch the active pair via memory/stack (push/pop/[hl], etc.).
  pair_eq_n_gap_is_safe:
    all:
      - not: { regex: CONTROL_FLOW_PREFIX }
      - not:
          all:
            - str_eq: { left: { current: code, byte_at: 0 }, right: { prev: { idx: 0, field: code }, byte_at: 0 } }
            - str_eq: { left: { current: code, byte_at: 1 }, right: { prev: { idx: 0, field: code }, byte_at: 1 } }
            - str_eq: { left: { current: code, byte_at: 2 }, right: { prev: { idx: 0, field: code }, byte_at: 2 } }
            - str_eq: { left: { current: code, byte_at: 3 }, right: { prev: { idx: 0, field: code }, byte_at: 3 } }
            - str_eq: { left: { current: code, byte_at: 4 }, right: { prev: { idx: 0, field: code }, byte_at: 4 } }
      - not: { code_starts_with: '.' }
      - not: { code_ends_with: ':' }
      - any:
          - all:
              - str_eq: { left: { prev: { idx: 0, field: code }, byte_at: 3 }, right: { const: 'h' } }
              - str_eq: { left: { prev: { idx: 0, field: code }, byte_at: 4 }, right: { const: 'l' } }
              - not: { code_contains: '[hl' }
              - not: { code_starts_with: 'push hl' }
              - not: { code_starts_with: 'pop hl' }
          - all:
              - str_eq: { left: { prev: { idx: 0, field: code }, byte_at: 3 }, right: { const: 'b' } }
              - str_eq: { left: { prev: { idx: 0, field: code }, byte_at: 4 }, right: { const: 'c' } }
              - not: { code_contains: '[bc' }
              - not: { code_starts_with: 'push bc' }
              - not: { code_starts_with: 'pop bc' }
          - all:
              - str_eq: { left: { prev: { idx: 0, field: code }, byte_at: 3 }, right: { const: 'd' } }
              - str_eq: { left: { prev: { idx: 0, field: code }, byte_at: 4 }, right: { const: 'e' } }
              - not: { code_contains: '[de' }
              - not: { code_starts_with: 'push de' }
              - not: { code_starts_with: 'pop de' }

  pair_add_step2:
    any:
      - all:
          - str_eq_in:
              left: { prev: { idx: 0, field: code }, after_prefix: 'add a, ', byte_at: 0 }
              rights: ['l', 'c', 'e']
          - str_eq:
              left: { current: code, after_prefix: 'ld ', before_comma: true, trim: true }
              right: { prev: { idx: 0, field: code }, after_prefix: 'add a, ', byte_at: 0 }
      - all:
          - str_eq_in:
              left: { prev: { idx: 0, field: code }, after_prefix: 'add ', byte_at: 0 }
              rights: ['l', 'c', 'e']
          - str_eq:
              left: { current: code, after_prefix: 'ld ', before_comma: true, trim: true }
              right: { prev: { idx: 0, field: code }, after_prefix: 'add ', byte_at: 0 }
      - all:
          - not:
              any:
                - str_eq_in:
                    left: { prev: { idx: 0, field: code }, after_prefix: 'add a, ', byte_at: 0 }
                    rights: ['l', 'c', 'e']
                - str_eq_in:
                    left: { prev: { idx: 0, field: code }, after_prefix: 'add ', byte_at: 0 }
                    rights: ['l', 'c', 'e']

  pair_add_step3:
    any:
      - all:
          - str_eq_in:
              left: { current: code, after_prefix: 'ld a, ', trim: true }
              rights: ['h', 'b', 'd']
          - str_eq:
              left: { current: code, after_prefix: 'ld a, ', trim: true }
              right: { prev: { idx: 1, field: code }, after_prefix: 'ld ', before_comma: true, trim: true, pair_reg: true }
      - not:
          str_eq_in:
            left: { current: code, after_prefix: 'ld a, ', trim: true }
            rights: ['h', 'b', 'd']

  pair_add_step4:
    any:
      - all:
          - str_eq_in:
              left: { current: code, after_prefix: 'adc ', trim: true }
              rights: ['h', 'b', 'd']
          - str_eq:
              left: { current: code, after_prefix: 'adc ', trim: true }
              right: { prev: { idx: 1, field: code }, after_prefix: 'ld ', before_comma: true, trim: true, pair_reg: true }
      - not:
          str_eq_in:
            left: { current: code, after_prefix: 'adc ', trim: true }
            rights: ['h', 'b', 'd']

  pair_add_step5:
    str_eq:
      left: { current: code, after_prefix: 'ld ', before_comma: true, trim: true }
      right: { prev: { idx: 1, field: code }, after_prefix: 'ld ', before_comma: true, trim: true, pair_reg: true }

  pair_add_jump_step4:
    str_eq:
      left: { current: code, after_prefix: 'inc ', trim: true }
      right: { prev: { idx: 1, field: code }, after_prefix: 'ld ', before_comma: true, trim: true, pair_reg: true }

  reg_conditional_ternary_step5:
    any:
      - { regex: LDH_R }
      - all:
          - code_in: ['xor a', 'xor a, a']
          - any:
              - str_eq:
                  left: { prev: { idx: 1, field: code }, after_prefix: 'ld ', before_comma: true, trim: true }
                  right: { const: 'a' }
              - str_eq:
                  left: { prev: { idx: 1, field: code }, after_prefix: 'ldh ', before_comma: true, trim: true }
                  right: { const: 'a' }

  reg_conditional_ternary_step6:
    any:
      - str_eq:
          left: { current: code }
          right: { prev: { idx: 2, field: code } }
      - str_eq:
          left: { current: code, strip_trailing_colon: true }
          right: { prev: { idx: 2, field: code }, last_token: true }

  pair_eq_deref_foo_step3:
    all:
      - not:
          str_eq:
            left: { prev: { idx: 0, field: code }, after_prefix: 'ld a, [', symbol_like: true }
            right: { const: '' }
      - str_eq:
          left: { prev: { idx: 0, field: code }, after_prefix: 'ld a, [', symbol_like: true }
          right: { current: code, after_prefix: 'ld a, [', symbol_like: true }

patterns:
  py_redundant_arguments:
    name: Redundant arguments
    description: "Bad: add a, X (or other arithmetic|logic operators). Good: add X"
    steps:
      - instruction_in:
          mnemonics: [add, adc, sub, sbc, and, xor, or, cp]
          operands:
            - { eq: a }
            - { any_operand: true }

  py_nops:
    name: nops
    description: "Bad: nop. Good: omit (unless you need it for timing or halt)"
    steps:
      - not:
          instruction: halt
      - instruction: nop

  py_no_op_ld:
    name: No-op ld
    description: "Bad: ld b, b (or other identical registers). Good: omit (unless you need it for timing)"
    steps:
      - all:
          - instruction:
              mnemonic: ld
              operands:
                - { is_reg8: true }
                - { is_reg8: true }
          - str_eq:
              left: { current: 'instruction, operand1', lower: true }
              right: { current: 'instruction, operand2', lower: true }

  py_no_op_add_sub:
    name: No-op add|sub
    description: "Bad: add|sub 0. Good: omit (unless you need the flag effects)"
    steps:
      - instruction_in:
          mnemonics: [add, sub]
          operands:
            - { is_zero_literal: true }

  py_inefficient_hram_load:
    name: Inefficient HRAM load
    description: "Bad: ld a, [hFoo] (or [rFoo]). Good: ldh a, [hFoo]"
    steps:
      - all:
          - instruction:
              mnemonic: ld
              operands:
                - { eq: a }
                - { is_mem: true, is_mem_r16: false, is_mem_hli: false, is_mem_hld: false }
          - str_eq_in:
              left: { current: 'instruction, operand2', lower: true, byte_at: 1 }
              rights: ['h', 'r']
          - not: is_bank_reg_symbol

  py_inefficient_hram_store:
    name: Inefficient HRAM store
    description: "Bad: ld [hFoo], a (or [rFoo]). Good: ldh [hFoo], a"
    steps:
      - all:
          - instruction:
              mnemonic: ld
              operands:
                - { is_mem: true, is_mem_r16: false, is_mem_hli: false, is_mem_hld: false }
                - { eq: a }
          - str_eq_in:
              left: { current: 'instruction, operand1', lower: true, byte_at: 1 }
              rights: ['h', 'r']
          - not: is_bank_reg_symbol

  py_a_eq_0:
    name: a = 0
    description: "Bad: ld a, 0. Good: xor a (unless you need to preserve flags)"
    steps:
      - instruction:
          mnemonic: ld
          operands:
            - { eq: a }
            - { is_zero_literal: true }

  py_a_inc_dec:
    name: a++|a--
    description: "Bad: add|sub 1. Good: inc|dec a (unless you need to set the carry flag)"
    steps:
      - instruction_in:
          mnemonics: [add, sub]
          operands:
            - { eq: a }
            - any:
                - { is_one_literal: true }

  py_a_times_2:
    name: a *= 2
    description: "Bad: sla a. Good: add a"
    steps:
      - instruction:
          mnemonic: sla
          operands:
            - { eq: a }

  py_a_not:
    name: a = ~a
    description: "Bad: xor $ff. Good: cpl"
    steps:
      - instruction:
          mnemonic: xor
          operands:
            - { number_eq: 255 }

  py_a_eq_n_minus_a:
    name: a = N - a
    description: "Bad: ld b, a / ld a, N / sub b (or other intermediate registers). Good: cpl / add N + 1"
    steps:
      - instruction: ld
        operands:
          - { is_reg8: true }
          - { eq: a }
      - instruction: ld
        operands:
          - { eq: a }
          - { is_imm: true }
      - all:
          - instruction: sub
            operands:
              - { is_reg8: true }
          - str_eq:
              left:
                current: instruction, operand1
                lower: true
              right:
                prev: { idx: 0, field: 'instruction, operand1' }
                lower: true

  py_a_eq_carry_pq:
    name: 'a = carry ? P : Q'
    description: "Bad: ld a, P / jr c|nc, .ok / ld a, Q / .ok. Bad: ld a, P / jr c|nc, .ok / xor|inc|dec a / .ok. Good: solutions involving sbc a"
    steps:
      - regex: LD_A_IMM
      - regex: JUMP_NC_OR_C
      - any:
          - { regex: LD_A_IMM }
          - { code_eq: 'xor a' }
          - { code_eq: 'inc a' }
          - { code_eq: 'dec a' }
      - str_eq:
          left: { current: code, strip_trailing_colon: true }
          right:
            prev: { idx: 1, field: code }
            after_comma: true
            trim: true

  py_a_inc_dec_if_carry:
    name: a++|a-- if carry
    description: "Bad: jr nc, .ok / { inc|dec a }+ / .ok. Good: adc|sbc 0"
    steps:
      - regex: JUMP_NC
      - code_in: ['inc a', 'dec a']
      - rewind: 1
        when:
          str_eq:
            left: { current: code, strip_trailing_colon: true }
            right:
              prev: { idx: 0, field: code }
              after_comma: true
              trim: true

  py_a_inc_dec_if_not_carry:
    name: a++|a-- if not carry
    description: "Bad: jr c, .ok / { inc|dec a }+ / .ok. Good: adc|sbc -1"
    steps:
      - regex: JUMP_C
      - code_in: ['inc a', 'dec a']
      - rewind: 1
        when:
          str_eq:
            left: { current: code, strip_trailing_colon: true }
            right:
              prev: { idx: 0, field: code }
              after_comma: true
              trim: true

  py_a_shift_right_3:
    name: a = a >> 3
    description: "Bad: srl a / srl a / srl a. Good: rrca / rrca / rrca / and %00011111"
    steps:
      - regex: SRL_A
      - regex: SRL_A
      - regex: SRL_A

  py_a_eq_x_plusminus_carry:
    name: a = X +/- carry
    description: "Bad: ld b, a / ld a, c|N / adc|sbc 0. Good: ld b, a / adc|sbc c|N / sub|add b"
    steps:
      - regex: LD_DST_A
      - all:
          - { code_starts_with: 'ld a,' }
          - any:
              - not: { code_starts_with: 'ld a, [' }
              - { code_eq: 'ld a, [hl]' }
      - regex: ADC_SBC_0

  py_a_eq_carry_plusminus_x:
    name: a = carry +/- X
    description: "Bad: ld b, a / ld a, 0 / adc|sbc c|N. Good: ld b, a / adc|sbc c|N / sub|add b"
    steps:
      - regex: LD_DST_A
      - regex: LD_A_0
      - any:
          - all:
              - code_starts_with: 'adc '
              - any:
                  - not: { code_starts_with: 'adc [' }
                  - code_eq: 'adc [hl]'
          - all:
              - code_starts_with: 'sbc '
              - any:
                  - not: { code_starts_with: 'sbc [' }
                  - code_eq: 'sbc [hl]'

  py_reg_conditional_ternary:
    name: 'a|b|c|d|e|h|l = z|nz|c|nc ? P : Q'
    description: "Bad: jr z|nz|c|nc, .p / ld a|b|c|d|e|h|l, Q / jr .ok / .p / (ld a|b|c|d|e|h|l, P | xor a) / (.ok | jr .ok). Good: ld a|b|c|d|e|h|l, Q / jr nz|z|nc|c, .ok / .p / (ld a|b|c|d|e|h|l, P | xor a) / .ok"
    steps:
      - regex: JUMP_NZ_OR_ZC
      - regex: LDH_R
      - all:
          - { regex: JR_JP_JMP_ANY }
          - not: { code_contains: ',' }
          - { code_ne: 'jp hl' }
      - str_eq:
          left: { current: code, strip_trailing_colon: true }
          right:
            prev: { idx: 0, field: code }
            after_comma: true
            trim: true
      - reg_conditional_ternary_step5
      - reg_conditional_ternary_step6

  py_a_and_x_eq_x:
    name: a & X == X
    description: "Bad: and N / cp N. Good: or ~N / inc a (unless you need the masked value or the carry flag)"
    steps:
      - regex: AND_IMM
      - all:
          - { regex: CP_IMM }
          - str_eq:
              left:
                current: code
                after_prefix: 'cp '
              right:
                prev: { idx: 0, field: code }
                after_prefix: 'and '

  py_a_mask_or:
    name: a = (a & MASK) | (b|c|d|e|h|l & ~MASK)
    description: "Bad: and MASK / ld c, a / ld a, b / and ~MASK / or c. Good: xor b / and MASK / xor b"
    steps:
      - regex: AND_IMM
      - regex: LD_RH_A
      - all:
          - { regex: LD_A_RH }
          - not:
              str_eq:
                left:
                  current: code
                  after_comma: true
                  trim: true
                right:
                  prev: { idx: 1, field: code }
                  after_prefix: 'ld '
                  before_comma: true
                  trim: true
      - regex: AND_IMM
      - all:
          - { regex: OR_R }
          - str_eq:
              left:
                current: code
                last_token: true
                trim: true
              right:
                prev: { idx: 1, field: code }
                after_prefix: 'ld '
                before_comma: true
                trim: true

  py_pair_add_a_or_n:
    name: hl|bc|de += a|N
    description: "Bad: add l|N / ld l, a / ld a, h|0 / adc 0|h / ld h, a (hl or bc or de). Good: add l|N / ld l, a / adc h / sub l / ld h, a"
    steps:
      - regex: ADD_A_LCE_OR_IMM
      - all:
          - regex: LD_LCE_A
          - pair_add_step2
      - all:
          - regex: LD_A_HBD_OR_0
          - pair_add_step3
      - all:
          - regex: ADC_HBD_OR_0
          - pair_add_step4
      - all:
          - regex: LD_HBD_A
          - pair_add_step5

  py_pair_add_a_or_n_jump:
    name: hl|bc|de += a|N (jump)
    description: "Okay: add l|N / ld l, a / jr nc, .noCarry / inc h / .noCarry. Good: add l|N / ld l, a / adc h / sub l / ld h, a"
    steps:
      - regex: ADD_A_LCE_OR_IMM
      - all:
          - regex: LD_LCE_A
          - pair_add_step2
      - regex: JUMP_NC
      - all:
          - code_starts_with: 'inc '
          - pair_add_jump_step4
      - str_eq:
          left: { current: code, strip_trailing_colon: true }
          right:
            prev: { idx: 2, field: code }
            after_comma: true
            trim: true

  py_pair_eq_foo_plus_a:
    name: hl|bc|de = Foo + a
    description: "Bad: ld hl, Foo / add l / ld l, a / adc h / sub l / ld h, a. Good: add LOW(Foo) / ld l, a / adc HIGH(Foo) / sub l / ld h, a"
    steps:
      - regex: LD_PAIR_IMM
      - all:
          - regex: ADD_LCE
          - str_eq:
              left: { current: code, last_char: true }
              right: { prev: { idx: 0, field: code }, byte_at: 4 }
      - all:
          - regex: LD_LCE_A
          - str_eq:
              left: { current: code, byte_at: 3 }
              right: { prev: { idx: 0, field: code }, byte_at: 4 }
      - all:
          - regex: ADC_HBD
          - str_eq:
              left: { current: code, last_char: true }
              right: { prev: { idx: 0, field: code }, byte_at: 3 }
      - all:
          - regex: SUB_LCE
          - str_eq:
              left: { current: code, last_char: true }
              right: { prev: { idx: 0, field: code }, byte_at: 4 }
      - all:
          - regex: LD_HBD_A
          - str_eq:
              left: { current: code, byte_at: 3 }
              right: { prev: { idx: 0, field: code }, byte_at: 3 }

  py_reg_plus_carry:
    name: b|c|d|e|h|l += carry
    description: "Bad: ld a, h|0 / adc 0|h / ld h, a. Good: jr nc, .noCarry / inc h / .noCarry"
    steps:
      - regex: LD_A_BCDEHL_OR_0
      - regex: ADC_BCDEHL_OR_0
      - all:
          - { regex: LD_RH_A }
          - any:
              - str_eq:
                  left:
                    current: code
                    byte_at: 3
                  right:
                    prev: { idx: 0, field: code }
                    byte_at: 6
              - str_eq:
                  left:
                    current: code
                    byte_at: 3
                  right:
                    prev: { idx: 1, field: code }
                    byte_at: 4
          - any:
              - str_eq:
                  left:
                    prev: { idx: 0, field: code }
                    last_char: true
                  right: { const: '0' }
              - str_eq:
                  left:
                    prev: { idx: 1, field: code }
                    last_char: true
                  right: { const: '0' }

  py_reg_minus_carry:
    name: b|c|d|e|h|l -= carry
    description: "Bad: ld a, h|0 / sbc 0|h / ld h, a. Good: jr nc, .noCarry / dec h / .noCarry"
    steps:
      - regex: LD_A_BCDEHL_OR_0
      - regex: SBC_BCDEHL_OR_0
      - all:
          - { regex: LD_RH_A }
          - any:
              - str_eq:
                  left:
                    current: code
                    byte_at: 3
                  right:
                    prev: { idx: 0, field: code }
                    byte_at: 6
              - str_eq:
                  left:
                    current: code
                    byte_at: 3
                  right:
                    prev: { idx: 1, field: code }
                    byte_at: 4
          - any:
              - str_eq:
                  left:
                    prev: { idx: 0, field: code }
                    last_char: true
                  right: { const: '0' }
              - str_eq:
                  left:
                    prev: { idx: 1, field: code }
                    last_char: true
                  right: { const: '0' }

  py_pair_eq_a_mul_16:
    name: hl|bc|de = a * 16
    description: "Bad: ld l, a / ld h, 0 / add hl, hl / add hl, hl / add hl, hl / add hl, hl. Good: solutions involving 'add a' or 'xor a' (if possible)"
    steps:
      - regex_in: [LD_LCE_A, LD_HBD_0]
      - all:
          - regex_in: [LD_LCE_A, LD_HBD_0]
          - not:
              str_eq:
                left: { current: code }
                right: { prev: { idx: 0, field: code } }
          - str_eq:
              left:
                current: code
                after_prefix: 'ld '
                before_comma: true
                trim: true
              right:
                prev: { idx: 0, field: code }
                after_prefix: 'ld '
                before_comma: true
                trim: true
                pair_reg: true
      - mul16_add_pair_matches_prev_ld
      - mul16_add_pair_matches_prev_ld
      - mul16_add_pair_matches_prev_ld
      - mul16_add_pair_matches_prev_ld

  py_pair_eq_a_mul_16_rept:
    name: hl|bc|de = a * 16 (rept)
    description: "Bad: ld l, a / ld h, 0 / rept 4 / add hl, hl / endr. Good: solutions involving 'add a' or 'xor a' (if possible)"
    steps:
      - regex_in: [LD_LCE_A, LD_HBD_0]
      - all:
          - regex_in: [LD_LCE_A, LD_HBD_0]
          - not:
              str_eq:
                left: { current: code }
                right: { prev: { idx: 0, field: code } }
          - str_eq:
              left:
                current: code
                after_prefix: 'ld '
                before_comma: true
                trim: true
              right:
                prev: { idx: 0, field: code }
                after_prefix: 'ld '
                before_comma: true
                trim: true
                pair_reg: true
      - regex: REPT_4_CI
      - mul16_add_pair_matches_prev_ld
      - regex: ENDR_CI

  py_hl_mul_2:
    name: hl *= 2
    description: "Bad: sla l / rl h. Good: add hl, hl"
    steps:
      - code_eq: 'sla l'
      - code_eq: 'rl h'

  py_pair_eq_deref_foo:
    name: hl = *Foo
    description: "Bad: ld a, [Foo] / ld l, a / ld a, [Foo+1] / ld h, a. Good: ld hl, Foo / ld a, [hli] / ld h, [hl] / ld l, a. Bad: ld a, [Foo] / ld h, a / ld a, [Foo+1] / ld l, a. Good: ld hl, Foo / ld a, [hli] / ld l, [hl] / ld h, a"
    steps:
      - regex: LD_A_MEM_NOT_HBD
      - regex: LD_LH_A
      - all:
          - { regex: LD_A_MEM_NOT_HBD }
          - pair_eq_deref_foo_step3
      - all:
          - { regex: LD_LH_A }
          - not:
              str_eq:
                left:
                  current: code
                  after_prefix: 'ld '
                  before_comma: true
                  trim: true
                right:
                  prev: { idx: 1, field: code }
                  after_prefix: 'ld '
                  before_comma: true
                  trim: true

  py_pair_load_pq:
    name: h,l|b,c|d,e = P,Q
    description: "Bad: ld b, P / ld c, Q. Good: lb bc, P, Q"
    steps:
      - regex: LD_R_IMM
      - all:
          - { regex: LD_R_IMM }
          - str_eq:
              left: { current: context }
              right: { prev: { idx: 0, field: context } }
          - str_eq:
              left:
                current: code
                after_prefix: 'ld '
                before_comma: true
                trim: true
              right:
                prev: { idx: 0, field: code }
                after_prefix: 'ld '
                before_comma: true
                trim: true
                pair_reg: true

  py_deref_hl_eq_n:
    name: '*hl = N'
    description: "Bad: ld a, N / ld [hl], a (unless you need N in a too). Good: ld [hl], N"
    steps:
      - regex: LD_A_IMM
      - code_eq: 'ld [hl], a'

  py_deref_hl_inc_dec:
    name: '*hl++|*hl--'
    description: "Bad: ld a, [hl] / { inc|dec a }+ / ld [hl], a. Good: inc|dec [hl] (before ld a, [hl] if you need [hl] in a too)"
    steps:
      - code_eq: 'ld a, [hl]'
      - code_in: ['inc a', 'dec a']
      - rewind: 1
        when: { code_eq: 'ld [hl], a' }

  py_deref_hl_inc_dec_eq_a:
    name: '*hl++|*hl-- = a'
    description: "Bad: ld [hl], a / inc|dec hl. Good: ld [hli|hld], a"
    steps:
      - code_eq: 'ld [hl], a'
      - code_in: ['inc hl', 'dec hl']

  py_deref_hl_inc_dec_eq_n:
    name: '*hl++|*hl-- = N'
    description: "Bad: ld [hl], N / inc|dec hl (unless you can't use a). Good: ld a, N / ld [hli|hld], a"
    steps:
      - regex: LD_MEMHL_IMM
      - code_in: ['inc hl', 'dec hl']

  py_a_eq_deref_hl_inc_dec:
    name: 'a = *hl++|*hl--'
    description: "Bad: ld a, [hl] / inc|dec hl. Good: ld a, [hli|hld]"
    steps:
      - code_eq: 'ld a, [hl]'
      - code_in: ['inc hl', 'dec hl']

  py_deref_hl_inc_dec_eq_r:
    name: '*hl++|*hl-- = b|c|d|e'
    description: "Bad: ld [hl], b|c|d|e|h|l / inc|dec hl (unless you can't use a). Good: ld a, b|c|d|e|h|l / ld [hli|hld], a"
    steps:
      - regex: LD_MEMHL_R
      - code_in: ['inc hl', 'dec hl']

  py_r_eq_deref_hl_inc_dec:
    name: 'b|c|d|e = *hl++|*hl--'
    description: "Bad: ld b|c|d|e, [hl] / inc|dec hl (unless you can't use a). Good: ld a, [hli|hld] / ld b|c|d|e, a"
    steps:
      - regex: LD_R_MEMHL
      - code_in: ['inc hl', 'dec hl']

  py_a_eq_0_cmp:
    name: a == 0
    description: "Bad: cp|or 0. Bad: and $ff. Good: and|or a"
    steps:
      - regex: CP_OR_0_OR_AND_FF

  py_a_eq_1_cmp:
    name: a == 1
    description: "Okay: cp 1. Good: dec a (unless you need a or carry)"
    steps:
      - regex: CP_1

  py_ei_ret:
    name: ei + ret
    description: "Bad: ei / ret. Good: reti"
    steps:
      - code_eq: ei
      - code_eq: ret

  py_tail_call:
    name: Tail call
    description: "Bad: call Foo / ret (unless Foo messes with the stack). Good: jr|jp Foo"
    steps:
      - all:
          - { code_starts_with: 'call ' }
          - not: { code_contains: ',' }
      - code_eq: ret

  py_tail_farcall:
    name: Tail farcall
    description: "Bad: farcall Foo / ret (unless Foo messes with the stack). Good: farjp Foo"
    steps:
      - all:
          - { code_starts_with: 'farcall ' }
          - not: { code_contains: ',' }
      - code_eq: ret

  py_tail_predef:
    name: Tail predef
    description: "Bad: predef Foo / ret. Good: predef_jump Foo"
    steps:
      - code_starts_with: 'predef '
      - code_eq: ret

  py_fallthrough:
    name: Fallthrough
    description: "Bad: call Foo / ret / Foo: .... Good: fall through to Foo: ..."
    steps:
      - all:
          - { code_starts_with: 'call ' }
          - not: { code_contains: ',' }
      - code_eq: ret
      - str_eq:
          left: { current: code, strip_trailing_colon: true }
          right:
            prev: { idx: 0, field: code }
            after_prefix: 'call '
            trim: true

  py_conditional_call:
    name: Conditional call
    description: "Bad: jr z|nz|c|nc, .skip / call Foo / .skip. Good: call nz|z|nc|c, Foo. Bad: jr z|nz|c|nc, .ok / call Foo / jr .ok. Good: call nz|z|nc|c, Foo / jr .ok"
    steps:
      - regex: JUMP_NZ_OR_ZC
      - all:
          - { code_starts_with: 'call ' }
          - not: { code_contains: ',' }
      - any:
          - all:
              - { regex: JR_JP_JMP_ANY }
              - not: { code_contains: ',' }
              - str_eq:
                  left:
                    current: code
                    last_token: true
                  right:
                    prev: { idx: 0, field: code }
                    after_comma: true
                    trim: true
          - str_eq:
              left: { current: code, strip_trailing_colon: true }
              right:
                prev: { idx: 0, field: code }
                after_comma: true
                trim: true

  py_conditional_return:
    name: Conditional return
    description: "Bad: jr z|nz|c|nc, .skip / ret / .skip. Good: ret nz|z|nc|c .bar"
    steps:
      - regex: JUMP_NZ_OR_ZC
      - code_eq: ret
      - str_eq:
          left: { current: code, strip_trailing_colon: true }
          right:
            prev: { idx: 0, field: code }
            after_comma: true
            trim: true

  py_conditional_fallthrough:
    name: Conditional fallthrough
    description: "Bad: jr z|nz|c|nc, .foo / jr .bar / .foo: .... Good: jr nz|z|nc|c .bar / .foo: ..."
    steps:
      - regex: JUMP_NZ_OR_ZC
      - all:
          - { regex: JR_JP_JMP_ANY }
          - not: { code_contains: ',' }
          - { code_ne: 'jp hl' }
      - str_eq:
          left: { current: code, strip_trailing_colon: true }
          right:
            prev: { idx: 0, field: code }
            after_comma: true
            trim: true

  py_call_hl:
    name: call hl
    description: "Bad: ld bc|de, Foo / push bc|de / jp hl / Foo: .... Good: call _hl_ (defined in home as _hl_:: jp hl)"
    steps:
      - regex: LD_BCDE_IMM_NOT_HBD
      - all:
          - any:
              - code_in: ['push bc', 'push de']
          - str_eq:
              left:
                current: code
                after_prefix: 'push '
                trim: true
              right:
                prev: { idx: 0, field: code }
                after_prefix: 'ld '
                before_comma: true
                trim: true
      - code_eq: 'jp hl'
      - str_eq:
          left: { current: code, strip_trailing_colon: true }
          right:
            prev: { idx: 0, field: code }
            after_comma: true
            trim: true

  py_pointless_hli_hld:
    name: Pointless hli|hld
    description: "Bad: { ld a, [hli|hld] | ld [hli|hld], a } / { ld hl, Foo | pop hl }. Good: { ld a, [hl] | ld [hl], a }"
    steps:
      - regex: POINTLESS_HLI_HLD_STEP1
      - rewind: 1
        when:
          all:
            - not: { regex: CONTROL_FLOW_PREFIX }
            - not: { regex: WORD_HL }
      - regex: LD_HL_IMM_OR_POP_HL

  py_pointless_jumps:
    name: Pointless jumps
    description: "Bad: jr|jp Foo / Foo: .... Good: fall through to Foo: ..."
    steps:
      - all:
          - { regex: POINTLESS_JUMPS_STEP1 }
          - not: { code_contains: ',' }
      - all:
          - str_eq:
              left: { current: code, strip_trailing_colon: true }
              right:
                prev: { idx: 0, field: code }
                last_token: true
          - any:
              - str_eq:
                  left: { current: context }
                  right: { prev: { idx: 0, field: context } }
              - str_eq:
                  left: { current: context }
                  right: { current: code }

  py_useless_loads:
    name: Useless loads
    description: "Bad: ld P, Q / ld P, R (unless the lds have side effects). Good: ld P, R"
    steps:
      - all:
          - is_ld_or_ldh
          - { code_contains: ',' }
          - not: volatile_operand
      - all:
          - is_ld_or_ldh
          - { code_contains: ',' }
          - not:
              any:
                - { code_eq: 'ld h, [hl]' }
                - { code_eq: 'ld l, [hl]' }
          - str_eq:
              left:
                current: code
                before_comma: true
              right:
                prev: { idx: 0, field: code }
                before_comma: true

  py_redundant_loads:
    name: Redundant loads
    description: "Bad: ld P, Q / ld Q, P (unless the lds have side effects). Good: ld P, Q"
    steps:
      - all:
          - is_ld_or_ldh
          - { code_contains: ',' }
          - not: volatile_operand
      - all:
          - is_ld_or_ldh
          - { code_contains: ',' }
          - str_eq:
              left: { current: context }
              right: { prev: { idx: 0, field: context } }
          - str_eq:
              left:
                current: code
                after_prefix: 'ld'
                before_comma: true
                last_token: true
                trim: true
              right:
                prev: { idx: 0, field: code }
                after_comma: true
                trim: true
          - str_eq:
              left:
                current: code
                after_comma: true
                trim: true
              right:
                prev: { idx: 0, field: code }
                after_prefix: 'ld'
                before_comma: true
                last_token: true
                trim: true

  py_similar_loads:
    name: Similar loads
    description: "Bad: ld P, X / ld a, X (unless the lds have side effects). Good: ld a, X / ld P, a (if possible)"
    steps:
      - all:
          - is_ld_or_ldh
          - { code_contains: ',' }
          - not: { regex: LOAD_SRC_IS_SINGLE_REG }
          - not: volatile_operand
      - all:
          - { code_starts_with: 'ld a,' }
          - str_eq:
              left:
                current: code
                after_comma_raw: true
              right:
                prev: { idx: 0, field: code }
                after_comma_raw: true

  py_conditionally_load_0:
    name: Conditionally load 0
    description: "Bad: and|or X / jr|jp nz, .foo / ld P, 0. Good: and|or X / jr|jp nz, .foo / ld P, a (if possible)"
    steps:
      - any:
          - { code_starts_with: 'and ' }
          - { code_starts_with: 'or ' }
      - regex: JR_NZ
      - regex: LD_ANY_0

  py_inefficient_prefix_opcodes:
    name: Inefficient prefix opcodes
    description: "Bad: rl|rlc|rr|rrc a (unless you need the z flag set for 0). Good: rla|rlca|rra|rrca"
    steps:
      - regex: PREFIX_A

  py_redundant_and_or:
    name: Redundant and|or
    description: "Bad: and|or|xor X / and|or a. Good: and|or|xor N"
    steps:
      - regex: AND_OR_XOR
      - regex: AND_OR_A

  py_pointless_and_or_a:
    name: Pointless and|or a
    description: "Bad: and|or a / (any instruction that affects z and c). Good: (the instruction that affects z and c)"
    steps:
      - regex: AND_OR_A
      - regex: AFFECTS_ZC

  py_redundant_inc_dec:
    name: Redundant inc|dec
    description: "Bad: ld P, N / inc|dec P (unless the inc|dec flags are needed). Good: ld P, X+/-1"
    steps:
      - regex: LD_ANY_IMM_NOT_REG_OR_MEM
      - any:
          - all:
              - { code_starts_with: 'inc ' }
              - str_eq:
                  left:
                    current: code
                    after_prefix: 'inc '
                    trim: true
                  right:
                    prev: { idx: 0, field: code }
                    before_comma: true
                    strip_prefix: 'ld'
                    trim: true
          - all:
              - { code_starts_with: 'dec ' }
              - str_eq:
                  left:
                    current: code
                    after_prefix: 'dec '
                    trim: true
                  right:
                    prev: { idx: 0, field: code }
                    before_comma: true
                    strip_prefix: 'ld'
                    trim: true

  py_pair_eq_n_then_other_then_add:
    name: hl|bc|de = N / bc|de|hl = K / hl|bc|de += bc|de|hl
    description: "Bad: hl|bc|de = N / bc|de|hl = K / hl|bc|de += bc|de|hl (unless K is needed in bc|de|hl). Good: hl|bc|de = N + K"
    steps:
      - regex: LD_PAIR_IMM
      - all:
          - { regex: LD_PAIR_IMM }
          - not:
              str_eq:
                left:
                  current: code
                  byte_at: 2
                right:
                  prev: { idx: 0, field: code }
                  byte_at: 3
      - rewind: 1
        when:
          all:
            - { regex: ADD_PAIR_THREE_STEP }
            - str_eq:
                left:
                  current: code
                  byte_at: 4
                right:
                  prev: { idx: 0, field: code }
                  byte_at: 3
            - str_eq:
                left:
                  current: code
                  byte_at: 8
                right:
                  prev: { idx: 1, field: code }
                  byte_at: 3

  py_pair_eq_n_then_inc_dec:
    name: hl|bc|de = N / ... / inc|dec hl|bc|de
    description: "Bad: hl|bc|de = N / ... / inc|dec hl|bc|de. Good: hl|bc|de = N +/- 1 / ..."
    steps:
      - regex: LD_PAIR_IMM
      - rewind: 1
        when: pair_eq_n_gap_is_safe
      - rewind: 1
        when:
          any:
            - all:
                - { code_starts_with: 'inc ' }
                - str_eq:
                    left:
                      current: code
                      after_prefix: 'inc '
                      trim: true
                    right:
                      prev: { idx: 0, field: code }
                      after_prefix: 'ld '
                      before_comma: true
                      trim: true
            - all:
                - { code_starts_with: 'dec ' }
                - str_eq:
                    left:
                      current: code
                      after_prefix: 'dec '
                      trim: true
                    right:
                      prev: { idx: 0, field: code }
                      after_prefix: 'ld '
                      before_comma: true
                      trim: true

  py_pair_eq_n_and_other_add:
    name: hl|bc|de = N / ... / bc|de|hl = K / hl|bc|de += bc|de|hl
    description: "Bad: hl|bc|de = N / ... / bc|de|hl = K / hl|bc|de += bc|de|hl (unless K is needed in bc|de|hl). Good: hl|bc|de = N + K / ..."
    steps:
      - regex: LD_PAIR_IMM
      - rewind: 1
        when: pair_eq_n_gap_is_safe
      - regex: LD_PAIR_IMM
      - rewind: 1
        when: pair_add_three_step_matches_prev_pairs

  py_dec_a_then_addntimes:
    name: dec a, then AddNTimes
    description: "Bad: ld hl, Foo / dec a / ld bc, BAR / call|rst AddNTimes. Bad: ld hl, Foo / ld bc, BAR / dec a / call|rst AddNTimes. Good: ld hl, Foo - BAR / ld bc, BAR / call|rst AddNTimes"
    steps:
      - regex: LD_HL_IMM
      - any:
          - { regex: LD_BC_IMM }
          - { code_eq: 'dec a' }
      - all:
          - any:
              - { regex: LD_BC_IMM }
              - { code_eq: 'dec a' }
          - any:
              - all:
                  - str_eq:
                      left: { current: code }
                      right: { const: 'dec a' }
                  - not:
                      str_eq:
                        left: { prev: { idx: 1, field: code } }
                        right: { const: 'dec a' }
              - all:
                  - not:
                      str_eq:
                        left: { current: code }
                        right: { const: 'dec a' }
                  - str_eq:
                      left: { prev: { idx: 1, field: code } }
                      right: { const: 'dec a' }
      - regex: CALL_RST_ADDNTIMES

  py_redundant_ret:
    name: Redundant ret
    description: "Bad: ret z|nz|c|nc / ret. Bad: ret / ret z|nz|c|nc. Bad: ret z / ret nz. Good: ret"
    steps:
      - any:
          - { code_eq: ret }
          - { code_starts_with: 'ret ' }
      - any:
          - { code_eq: ret }
          - all:
              - { code_starts_with: 'ret ' }
              - any:
                  - str_eq:
                      left: { prev: { idx: 0, field: code } }
                      right: { const: 'ret' }
                  - str_eq:
                      left:
                        current: code
                        last_char: true
                      right:
                        prev: { idx: 0, field: code }
                        last_char: true

  py_stub_function:
    name: Stub function
    description: "Bad: call [z|nz|c|nc,] Foo / ... / Foo: / ret. Good: (do nothing). Bad: jr|jp [z|nz|c|nc,] Foo / ... / Foo: / ret. Good: ret [z|nz|c|nc]"
    steps:
      - label_definition_line
      - code_eq: ret

  py_stub_jump:
    name: Stub jump
    description: "Bad: call [z|nz|c|nc,] Foo / ... / Foo: / jr Bar. Good: call [z|nz|c|nc,] Bar. Bad: jr|jp [z|nz|c|nc,] Foo / ... / Foo: / jr Bar. Good: jr|jp [z|nz|c|nc,] Bar"
    steps:
      - label_definition_line
      - all:
          - { code_starts_with: 'jr ' }
          - not: { code_contains: ',' }

  py_wram_inc_dec:
    name: Inefficient WRAM increment/decrement
    description: "Bad: ld a, [wFoo] / inc|dec a / ld [wFoo], a (unless hl needs to be preserved). Good: ld hl, wFoo / inc|dec [hl]"
    steps:
      - regex: LD_WRAM_LOAD
      - code_in: ['inc a', 'dec a']
      - all:
          - { regex: LD_WRAM_STORE }
          - str_eq:
              left:
                current: code
                before_comma: true
                strip_prefix: 'ld '
                trim: true
              right:
                prev: { idx: 0, field: code }
                after_comma: true
                trim: true

  py_trailing_string_space:
    name: Trailing string space
    description: 'Bad: text "Hello! " (unless it''s followed by a text command). Good: text "Hello!"'
    steps:
      - regex: TEXT_TRAILING_SPACE
      - not: { regex: TEXT_COMMAND_FOLLOWS }

  no_op_add_sub:
    name: No-op add|sub
    description: "Bad: add|sub 0. Good: omit (unless you need the flag effects)"
    steps:
      - any:
          - instruction:
              mnemonic: add
              operands:
                - { is_zero_literal: true }
          - instruction:
              mnemonic: sub
              operands:
                - { is_zero_literal: true }
          - instruction:
              mnemonic: add
              operands:
                - { eq: a }
                - { is_zero_literal: true }
          - instruction:
              mnemonic: sub
              operands:
                - { eq: a }
                - { is_zero_literal: true }

  ld_a_from_hli:
    name: Load a from [hli]/[hl+]
    description: "Load a from [hli]/[hl+]"
    steps:
      - instruction:
          mnemonic: ld
          operands:
            - { eq: a }
            - { canon_eq: '[hli]' }

packs:
  core:
    patterns:
      - py_no_op_ld
      - no_op_add_sub
      - ld_a_from_hli

  rgbds:
    patterns:
      - py_redundant_arguments
      - py_nops
      - py_no_op_ld
      - no_op_add_sub
      - py_a_eq_0
      - py_a_inc_dec
      - py_a_times_2
      - py_a_not
      - ld_a_from_hli

  pret:
    patterns:
      - py_redundant_arguments
      - py_nops
      - py_no_op_ld
      - py_no_op_add_sub
      - py_inefficient_hram_load
      - py_inefficient_hram_store
      - py_a_eq_0
      - py_a_inc_dec
      - py_a_times_2
      - py_a_not
      - py_a_eq_n_minus_a
      - py_a_eq_carry_pq
      - py_a_inc_dec_if_carry
      - py_a_inc_dec_if_not_carry
      - py_a_shift_right_3
      - py_a_eq_x_plusminus_carry
      - py_a_eq_carry_plusminus_x
      - py_reg_conditional_ternary
      - py_a_and_x_eq_x
      - py_a_mask_or
      - py_pair_add_a_or_n
      - py_pair_add_a_or_n_jump
      - py_pair_eq_foo_plus_a
      - py_reg_plus_carry
      - py_reg_minus_carry
      - py_pair_eq_a_mul_16
      - py_pair_eq_a_mul_16_rept
      - py_hl_mul_2
      - py_pair_eq_deref_foo
      - py_pair_load_pq
      - py_deref_hl_eq_n
      - py_deref_hl_inc_dec
      - py_deref_hl_inc_dec_eq_a
      - py_deref_hl_inc_dec_eq_n
      - py_a_eq_deref_hl_inc_dec
      - py_deref_hl_inc_dec_eq_r
      - py_r_eq_deref_hl_inc_dec
      - py_a_eq_0_cmp
      - py_a_eq_1_cmp
      - py_ei_ret
      - py_tail_call
      - py_tail_farcall
      - py_tail_predef
      - py_fallthrough
      - py_conditional_call
      - py_conditional_return
      - py_conditional_fallthrough
      - py_call_hl
      - py_pointless_hli_hld
      - py_pointless_jumps
      - py_useless_loads
      - py_redundant_loads
      - py_similar_loads
      - py_conditionally_load_0
      - py_inefficient_prefix_opcodes
      - py_redundant_and_or
      - py_pointless_and_or_a
      - py_redundant_inc_dec
      - py_pair_eq_n_then_other_then_add
      - py_pair_eq_n_then_inc_dec
      - py_pair_eq_n_and_other_add
      - py_dec_a_then_addntimes
      - py_redundant_ret
      - py_stub_function
      - py_stub_jump
      - py_wram_inc_dec
      - py_trailing_string_space
